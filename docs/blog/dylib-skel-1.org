#+TITLE: dylib-skel (part 1)
* Overview
+ CODE :: [[https://lab.rwest.io/packy/stash/dysk][packy/stash/dysk]]
Our core languages are [[https://www.rust-lang.org/][Rust]] and [[https://lisp-lang.org/][Lisp]] - this is the killer combo which will allow NAS-T
to rapidly develop high-quality software. As such, it's crucial that these two very
different languages (i.e. compilers) are able to interoperate seamlessly.

Some interop methods are easy to accomodate via the OS - such as IPC or data sharing,
but others are a bit more difficult.

In this 2-part series we'll build a FFI bridge between Rust and Lisp, which is something
that /can/ be difficult, due to some complications with Rust and because this is not the
most popular software stack (yet ;). This is an experiment and may not make it to our
code-base, but it's definitely something worth adding to the toolbox in case we need it.
** FFI
The level of interop we're after in this case is [[https://en.wikipedia.org/wiki/Foreign_function_interface][FFI]].

Basically, calling Rust code from Lisp and vice-versa. There's an article about calling
Rust from Common Lisp [[https://dev.to/veer66/calling-rust-from-common-lisp-45c5][here]] which shows the basics and serves as a great starting point
for those interested.
*** Nothing wrong with C
*** Rust ABI
The complication(s) with Rust I mentioned early is really just that /it is not C/. =C=
is old, i.e. well-supported with a stable ABI, making the process of creating bindings
for a C library a breeze in many languages.

For a Rust library we need to first appease the compiler, as explained in [[https://doc.rust-lang.org/nomicon/ffi.html#calling-rust-code-from-c][this section]]
of the Rustonomicon. Among other things it involves changing the calling-convention of
functions with a type signature and editing the Cargo.toml file to produce a
C-compatible ABI binary. The Rust default ABI is unstable and can't reliably be used
like the C ABI can.

[[https://github.com/rodrimati1992/abi_stable_crates][abi_stable_crates]] is a project which addresses some of the ABI concerns, presenting a
sort of ABI-API as a Rust library. Perhaps this is the direction the ecosystem will go
with in order to maintain an unstable ABI, but for now there is no 'clear' pathway for a
friction-less FFI development experience in Rust.

*** Overhead
Using FFI involves some overhead. Check [[https://github.com/dyu/ffi-overhead][here]] for an example benchmark across a few
languages. While building the NAS-T core, I'm very much aware of this, and will need a
few sanity benchmarks to make sure the cost doesn't outweigh the benefit. In particular,
I'm concerned about crossing multiple language barriers (Rust<->C<->Lisp).

* basic
** Setup
For starters, I'm going to assume we all have Rust (via =rustup=) and Lisp (=sbcl= only)
installed on our GNU/Linux system (some tweaks needed for Darwin/Windows, not covered in
this post).
*** Cargo
Create a new library crate. For this example we're focusing on a 'skeleton' for
/dynamic/ libraries only, so our experiment will be called =dylib-skel= or *dysk* for
short.
src_sh[:exports code]{cargo init dysk --lib && cd dysk} 

A =src/lib.rs= will be generated for you. Go ahead and delete that. We're going to be
making our own =lib.rs= file directly in the root directory (just to be cool).

The next step is to edit your =Cargo.toml= file. Add these lines after the =[package]=
section and before =[dependencies]=:
#+begin_src conf-toml
[lib]
crate-type = ["cdylib","rlib"]
path = "lib.rs"
[[bin]]
name="dysk-test"
path="test.rs"
#+end_src

This tells Rust to generate a shared C-compatible object with a =.so= extension which we
can open using [[https://man.archlinux.org/man/dlopen.3.en][dlopen]].
*** cbindgen
**** install
Next, we want the =cbindgen= program which we'll use to generate header files for
C/C++. This step isn't necessary at all, we just want it for further experimentation.

src_sh[:exports code]{cargo install --force cbindgen}

We append the =cbindgen= crate as a /build dependency/ to our =Cargo.toml= like so:
#+begin_src conf-toml
[build-dependencies]
cbindgen = "0.24"
#+end_src
**** cbindgen.toml
#+begin_src conf-toml :tangle cbindgen.toml
language = "C"
autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
include_version = true
namespace = "dysk"
cpp_compat = true
after_includes = "#define DYSK_VERSION \"0.1.0\""
line_length = 88
tab_width = 2
documentation = true
documentation_style = "c99"
usize_is_size_t = true
[cython]
header = "dysk.h"
#+end_src
**** build.rs
#+begin_src rust :tangle build.rs
fn main() -> Result<(), cbindgen::Error> {
  if let Ok(b) = cbindgen::generate(std::env::var("CARGO_MANIFEST_DIR").unwrap()) {
    b.write_to_file("dysk.h"); Ok(())}
  else { panic!("failed to generate dysk.h from cbindgen.toml") } }
#+end_src
** lib.rs
#+begin_src rust :tangle lib.rs
//! lib.rs --- dysk library
use std::ffi::{c_char, c_int, CString};
#[no_mangle]
pub extern "C" fn hello() -> *const c_char {
  CString::new("hello from rust").unwrap().into_raw()}
#[no_mangle]
pub extern "C" fn plus(a:c_int,b:c_int) -> c_int {a+b}
#[no_mangle]
pub extern "C" fn plus1(n:c_int) -> c_int {n+1}
#+end_src
** test.rs
#+begin_src rust :tangle test.rs
//! test.rs --- dysk test
fn main() { let mut i = 0u32; while i < 500000000 {i+=1; dysk::plus1(2 as core::ffi::c_int);}}
#+end_src
** compile
#+begin_src sh
cargo build --release
#+end_src
** load from SBCL
#+begin_src lisp :tangle dysk.lisp
;;; dysk.lisp
;; (dysk:hello) ;; => "hello from rust"
(defpackage :dysk
  (:use :cl :sb-alien)
  (:export :hello :plus :plus1))
(in-package :dysk)
(load-shared-object #P"target/release/libdysk.so")
(define-alien-routine hello c-string)
(define-alien-routine plus int (a int) (b int))
(define-alien-routine plus1 int (n int))
#+end_src
** benchmark
#+begin_src shell
time target/release/dysk-test
#+end_src
#+begin_src lisp :tangle test.lisp
(time (dotimes (_ 500000000) (dysk:plus1 2)))
#+end_src

* quiche
Moving right along, our next example involves Cloudflare's [[https://github.com/cloudflare/quiche/tree/master][quiche]] crate, which is a Rust
implementation of the QUIC transport protocol and HTTP/3 (more on that later).

quiche is implemented in Rust, but exposes a thin C API for FFI purposes which is
perfect for our use-case.

Like the previous example, it isn't necessary to generate a C header file but it's
useful for reference. Here's [[https://github.com/cloudflare/quiche/blob/master/quiche/include/quiche.h][quiche.h]].

** Setup
Clone the quiche source code somewhere close and build it:
#+begin_src shell
git clone https://github.com/cloudflare/quiche  lib
cd lib && cargo build --release --features ffi
#+end_src

Create a =quiche.lisp= file with the following boilerplate code:
#+begin_src lisp
(defpackage :dysk.quiche
  (:use :cl :sb-alien))
(in-package :dysk.basic)
(load-shared-object #P"lib/target/release/libquiche.so")
#+end_src

Now when you load =quiche.lisp= and connect a repl, we'll have access to the symbols in
=libquiche.so= which we can build an API around /interactively/. Neat!

#+begin_src shell
sbcl --load quiche.lisp
#+end_src

#+begin_src lisp
(in-package :dysk.quiche)
(define-alien-routine quiche-version c-string) ;; >> QUICHE-VERSION
(quiche-version) ;; >> "0.18.0"
#+end_src
