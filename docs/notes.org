#+TITLE: notes
#+BIBLIOGRAPHY: refs.bib
#+TODO: TIP REF NOTE | OK
* Log
** Thinking Fast, Going Slow
- [2023-08-01 Tue] :: /a note from the author/ \\
  Greetings stranger. My name is Richard Westhaver and I'm a computer
  programmer living in Connecticut. I started this company as a means
  to provide high-quality NAS solutions to my local community and
  empower others to do the same. There is much work to be done but
  it's quite exciting, and I hope you will be along for the ride :).

  Right now, the ideas are flowing and I'm working through a list of
  experiments, piecing together the perfect solution - the one with
  the most power. Some hardware experiments will follow in the coming
  weeks.

  At this stage, my goals are:
  1. think fast - develop /good/ ideas as quickly as humanly possible
  2. go slow - prioritize detailed implementations

  PS. the website ([[file:infra/web][infra/web]]) is somewhat of an exception - we're just
  throwing that online and coming back to work out the kludges later.

* File Systems                                                           :fs:
** BTRFS                                                             :btrfs:
#+begin_quote
BTRFS is a Linux filesystem based on copy-on-write, allowing for
efficient snapshots and clones.

It uses B-trees as its main on-disk data structure. The design goal is
to work well for many use cases and workloads. To this end, much
effort has been directed to maintaining even performance as the
filesystem ages, rather than trying to support a particular narrow
benchmark use-case.

Linux filesystems are installed on smartphones as well as enterprise
servers. This entails challenges on many different fronts.

- Scalability :: The filesystem must scale in many dimensions: disk
  space, memory, and CPUs.

- Data integrity :: Losing data is not an option, and much effort is
  expended to safeguard the content. This includes checksums, metadata
  duplication, and RAID support built into the filesystem.

- Disk diversity :: The system should work well with SSDs and hard
  disks. It is also expected to be able to use an array of different
  sized disks, which poses challenges to the RAID and striping
  mechanisms.
#+end_quote
-- [cite/t/f:@btrfs]
*** [2023-08-08 Tue] btrfs performance speculation ::
  - [[https://www.percona.com/blog/taking-a-look-at-btrfs-for-mysql/]]
    - zfs outperforms immensely, but potential misconfiguration on btrfs side (virt+cow
      still enabled?)
  - https://www.ctrl.blog/entry/btrfs-vs-ext4-performance.html
    - see the follow up comment on this post
      - https://www.reddit.com/r/archlinux/comments/o2gc42/is_the_performance_hit_of_btrfs_serious_is_it/
            #+begin_quote
      I’m the author of OP’s first link. I use BtrFS today. I often shift lots of
      de-duplicatable data around, and benefit greatly from file cloning. The data is actually
      the same data that caused the slow performance in the article. BtrFS and file cloning
      now performs this task quicker than a traditional file system. (Hm. It’s time for a
      follow-up article.)

      In a laptop with one drive: it doesn’t matter too much unless you do work that benefit
      from file cloning or snapshots. This will likely require you to adjust your tooling and
      workflow. I’ve had to rewrite the software I use every day to make it take advantage of
      the capabilities of a more modern file system. You won’t benefit much from the data
      recovery and redundancy features unless you’ve got two storage drives in your laptop and
      can setup redundant data copies.

          on similar hardware to mine?

      It’s not a question about your hardware as much as how you use it. The bad performance I
      documented was related to lots and lots of simultaneous random reads and writes. This
      might not be representative of how you use your computer.
            #+end_quote
  - https://dl.acm.org/doi/fullHtml/10.1145/3386362
    - this is about distributed file systems (in this case Ceph) - they argue against
      basing DFS on ondisk-format filesystems (XFS ext4) - developed BlueStore as
      backend, which runs directly on raw storage hardware.
    - this is a good approach, but expensive (2 years in development) and risky
    - better approach is to take advantage of a powerful enough existing ondisk-FS
      format and pair it with supporting modules which abstract away the 'distributed'
      mechanics.
    - the strategy presented here is critical for enterprise-grade hardware where the
      ondisk filesystem becomes the bottleneck that you're looking to optimize
  - https://lore.kernel.org/lkml/cover.1676908729.git.dsterba@suse.com/
    - linux 6.3 patch by David Sterba [2023-02-20 Mon]
    - btrfs continues to show improvements in the linux kernel, ironing out the kinks
    - makes it hard to compare benchmarks tho :/
*** MacOS support
- see this WIP k-ext for macos: [[https://github.com/relalis/macos-btrfs][macos-btrfs]]
  - maybe we can help out with the VFS/mount support
*** on-disk format
- [[https://btrfs.readthedocs.io/en/latest/dev/On-disk-format.html][on-disk-format]]
- 'btrfs consists entirely of several trees. the trees use copy-on-write.'
- trees are stored in nodes which belong to a level in the b-tree structure.
- internal nodes (inodes) contain refs to other inodes on the /next/ level OR
  - to leaf nodes then the level reaches 0.
- leaf nodes contain various types depending on the tree.
- basic structures
  - 0:8 uint = objectid, each tree has its own set of object IDs
  - 8:1 uint = item type
  - 9:8 uint = offset, depends on type.
  - little-endian
  - fields are unsigned
  - *superblock*
    - primary superblock is located at 0x10000 (64KiB)
    - Mirror copies of the superblock are located at physical addresses 0x4000000 (64
      MiB) and 0x4000000000 (256GiB), if valid. copies are updated simultaneously.
    - during mount only the first super block at 0x10000 is read, error causes mount to
      fail.
    - BTRFS onls recognizes disks with a valid 0x10000 superblock.
  - *header*
    - stored at the start of every inode
    - data following it depends on whether it is an internal or leaf node.
  - *inode*
    - node header followed by a number of key pointers
    - 0:11 key
    - 11:8 uint = block number
    - 19:8 uint = generation
  - *lnode*
    - leaf nodes contain header followed by key pointers
    - 0:11 key
    - 11:4 uint = data offset relative to end of header(65)
    - 15:4 uint = data size
- objects
  - ROOT_TREE
    - holds ROOT_ITEMs, ROOT_REFs, and ROOT_BACKREFs for every tree other than itself.
    - used to find the other trees and to determine the subvol structure.
    - holds items for the 'root tree directory'. laddr is store in the superblock
  - objectIDs
    - free ids: BTRFS_FIRST_FREE_OBJECTID=256ULL:BTRFS_LAST_FREE_OBJECTID=-256ULL
    - otherwise used for internal use
*** send-stream format
- [[https://btrfs.readthedocs.io/en/latest/dev/dev-send-stream.html][send stream format]]
- Send stream format represents a linear sequence of commands describing actions to be
  performed on the target filesystem (receive side), created on the source filesystem
  (send side).
- The stream is currently used in two ways: to generate a stream representing a
  standalone subvolume (full mode) or a difference between two snapshots of the same
  subvolume (incremental mode).
- The stream can be generated using a set of other subvolumes to look for extent
  references that could lead to a more efficient stream by transferring only the
  references and not full data.
- The stream format is abstracted from on-disk structures (though it may share some
  BTRFS specifics), the stream instructions could be generated by other means than the
  send ioctl.
- it's a checksum+TLV
- header: u32len,u16cmd,u32crc32c
- data: type,length,raw data
- the v2 protocol supports the encoded commands
- the commands are kinda clunky - need to MKFIL/MKDIR then RENAM to create
*** [2023-08-09 Wed] ioctls
- magic#: 0x94 
  - https://docs.kernel.org/userspace-api/ioctl/ioctl-number.html
  - Btrfs filesystem some lifted to vfs/generic
  - fs/btrfs/ioctl.h and linux/fs.h
** ZFS                                                                 :zfs:
-- [cite/t/f:@zfs]

- core component of TrueNAS software
** TMPFS                                                             :tmpfs:
-- [cite/t/f:@tmpfs]
- in-mem FS
** EXT4                                                               :ext4:
-- [cite/t/f:@ext4]
** XFS                                                                 :xfs:
-- [cite/t/f:@xfs]
-- [cite/t/f:@xfs-scalability]
* Storage Mediums                                                   :data:hw:
** HDD                                                                 :hdd:
-- [cite/t/f:@hd-failure-ml]
** SSD                                                                 :ssd:
-- [cite/t/f:@smart-ssd-qp]
-- [cite/t/f:@ssd-perf-opt]
https://dl.acm.org/doi/abs/10.1145/3599691.3603412
https://storageconference.us/2019/Research/ParallelAllTheTime.pdf
https://users.rust-lang.org/t/parallelizing-ssd-reads-and-subsequent-computations/91288/20
https://www.xda-developers.com/crucial-t700-ssd-review/
[[https://www.csc.lsu.edu/~fchen/publications/papers/TOS16.pdf]]
** Flash                                                             :flash:
-- [cite/t/f:@flash-openssd-systems]
** NVMe                                                               :nvme:
-- [cite/t/f:@nvme-ssd-ux]
-- [[https://nvmexpress.org/specifications/][specifications]]
*** ZNS
-- [cite/t/f:@zns-usenix]
#+begin_quote
Zoned Storage is an open source, standards-based initiative to enable data centers to
scale efficiently for the zettabyte storage capacity era. There are two technologies
behind Zoned Storage, Shingled Magnetic Recording (SMR) in ATA/SCSI HDDs and Zoned
Namespaces (ZNS) in NVMe SSDs.
#+end_quote
-- [[https://zonedstorage.io/][zonedstorage.io]]
-- $465 8tb 2.5"? [[https://www.serversupply.com/SSD/PCI-E/7.68TB/WESTERN%20DIGITAL/WUS4BB076D7P3E3_332270.htm][retail]]
** eMMC                                                               :emmc:
-- [cite/t/f:@emmc-mobile-io]
* Linux                                                               :linux:
** syscalls
*** ioctl
- [[https://elixir.bootlin.com/linux/latest/source/Documentation/userspace-api/ioctl/ioctl-number.rst][ioctl-numbers]]
* HPC                                                                   :hpc:
** MPI
[[https://www.mpi-forum.org/docs/][MPI Documents]]
[[https://docs.open-mpi.org/en/v5.0.x/][Open MPI v5 docs]]
[[https://en.wikipedia.org/wiki/Message_Passing_Interface][wiki]]
[[https://github.com/marcoheisig/cl-mpi][cl-mpi]]
** HDF5
[[https://www.hdfgroup.org/]]
* Memory                                                                :mem:
https://www.cidrdb.org/cidr2022/papers/p13-crotty.pdf
* Rust                                                                 :rust:
** crates
*** nix
- [[https://crates.io/crates/nix][crates.io]]
*** memmap2
- [[https://crates.io/crates/memmap2][crates.io]]
*** zstd
- [[https://crates.io/crates/zstd][crates.io]]
*** rocksdb
- [[https://crates.io/crates/rocksdb][crates.io]]
*** tokio                                                           :tokio:
- [[https://crates.io/crates/tokio][crates.io]]
*** tracing                                                         :tokio:
- [[https://crates.io/crates/tracing][crates.io]]
**** tracing-subscriber
- [[https://crates.io/crates/tracing-subscriber][crates.io]]
*** axum                                                            :tokio:
- [[https://crates.io/crates/axum][crates.io]]
*** tower                                                           :tokio:
- [[https://crates.io/crates/tower][crates.io]]
*** uuid
- [[https://crates.io/crates/uuid][crates.io]]
** unstable
*** lazy_cell
- [[https://github.com/rust-lang/rust/issues/109736][tracking-issue]]
*** {BTreeMap,BTreeSet}::extract_if
- [[https://github.com/rust-lang/rust/issues/70530][tracking-issue]]
* Lisp                                                                 :lisp:
- [cite/t/f:@lisp-different]
- [[https://en.wikipedia.org/wiki/Format_(Common_Lisp)#Format_directives][Format directives]]
- [[https://www.reddit.com/r/Common_Lisp/comments/c1nfsv/optimising_common_lisp/][Optimizing Common Lisp (reddit)]]
- [[http://clhs.lisp.se/Body/d_dynami.htm][Dynamic Extent (clhs)]]
- [[https://m00natic.github.io/lisp/manual-jit.html][manual-jit]]
- [[https://blog.kingcons.io/posts/Going-Faster-with-Lisp.html][Going Faster With Lisp]]
- [[https://unthought.net/2016/12/22-lisp-memory-woes-but-not/][Lisp memory woes, but not]]
** SBCL                                                               :sbcl:
SBCL is our Common Lisp compiler of choice. We make heavy use of the implementation
details in our software and it's infeasible to consider building our code with a
different compiler.
- [cite/t/f:@lisp-internals]
- quick note on optimizations:
  #+begin_quote
  There is no doubt that the grail of efficiency leads to abuse. Programmers waste
  enormous amounts of time thinking about, or worrying about, the speed of noncritical
  parts of their programs, and these attempts at efficiency actually have a strong
  negative impact when debugging and maintenance are considered. We should forget about
  small efficiencies, say about 97% of the time: premature optimization is the root of all
  evil. Yet we should not pass up our opportunities in that critical 3%. A good programmer
  will not be lulled into complacency by such reasoning, he will be wise to look carefully
  at the critical code; but only after that code has been identified.
  #+end_quote
  -- Knuth, Structured Programming with go to Statements

*** GC                                                                 :gc:
- [[https://medium.com/@MartinCracauer/llvms-garbage-collection-facilities-and-sbcl-s-generational-gc-a13eedfb1b31][LLVM and SBCL GC]]
- [[https://www.cons.org/cracauer/cracauer-userfaultfd.c][cracauer-userfaultfd.c]]
- Q :: how can we use kernel-level monitoring to improve GC?
  - both at runtime and compile
  - BPF?
    - [[https://medium.com/@yunwei356/ebpf-tutorial-by-example-15-capturing-user-space-java-gc-event-duration-using-usdt-46436f772ce8][java-gc-usdt]] - insert trace points
    - [[https://theartofmachinery.com/2019/04/26/bpftrace_d_gc.html][d-gc]] - bpftrace
- [2023-09-04 Mon] a new mark-region GC was merged last month
  - [[https://applied-langua.ge/~hayley/swcl-gc.pdf][paper]]
  - [[https://github.com/sbcl/sbcl/blob/master/doc/internals-notes/mark-region][internal-notes]]
  - [[https://github.com/no-defun-allowed/swcl][upstream repo]] - no-defun-allowed / Steel Wool Common Lisp - I like this guy already
    lol
#+name: SBCL dynamic heap layout
[[https://miro.medium.com/v2/resize:fit:4800/format:webp/1*C4-RE62lyEDyn59uDOODIQ.png]]
*** XC                                                                 :xc:
One problem unique to Lisps is best described by the SBCL folks here in the =Instruction
Set Dispatch= section of the =sb-simd= docs:

#+begin_quote
One challenge that is unique to image-based programming systems such as Lisp is that a
program can run on one machine, be dumped as an image, and then resumed on another
machine. While nobody expects this feature to work across machines with different
architectures, it is quite likely that the machine where the image is dumped and the one
where execution is resumed provide different instruction set extensions.

As a practical example, consider a game developer that develops software on an x86-64
machine with all SIMD extensions up to AVX2, but then dumps it as an image and ships it
to a customer whose machine only supports SIMD extensions up to SSE2. Ideally, the image
should contain multiple optimized versions of all crucial functions, and dynamically
select the most appropriate version based on the instruction set extensions that are
actually available.

This kind of run time instruction set dispatch is explicitly supported by means of the
=instruction-set-case= macro. The code resulting from an invocation of this macro
compiles to an efficient jump table whose index is recomputed on each startup of the
Lisp image.
#+end_quote
*** ASM                                                               :asm:
The type of assembly workflow we're after is basically Lisp<->Forth->Codes.
- Don't call an external assembler (nasm,fasm,gas) - build your own or wrap SBCL's
  =sb-assem:assemble=.
- Define a Forth compiler in Lisp.
- Define words (op,noun,verb,inst) and vocabs for instruction sets.
- Write Lisp which compiles to Forth, or just write Forth and then:
- compile your Forth, and feed it to your assembler.

Note the two-way channel between Lisp and Forth. This is where things can get really
interesting - where you may call Lisp from Forth or call Forth from Lisp. My intention
is to treat our Forth(s) as a 'control language' for an assembler - currently only at
compile-time but the natural evolution would be runtime support on various
platforms.

- [[https://pvk.ca/Blog/2014/03/15/sbcl-the-ultimate-assembly-code-breadboard/][SBCL: the ultimate assembly code breadboard]]
- [[https://pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/][how to define new intrinsics in SBCL]]
- [[https://iq.opengenus.org/peephole-optimization-in-compiler-design/][peephole optimization in compiler design]]
  - check the Research Issues section, all relevant to modern design
*** DLL                                                               :dll:
- [[https://www.sbcl.org/sbcl-internals/Foreign-Linkage.html][sbcl-internals/Foreign-Linkage]]
- [[https://www.sbcl.org/sbcl-internals/Callbacks.html][sbcl-internals/callbacks]]
** ASDF                                                              :packy:
- [[https://gitlab.common-lisp.net/asdf/asdf][gitlab.common-lisp.net]]
- [[https://asdf.common-lisp.dev/][common-lisp.dev]]
- [[https://github.com/fare/asdf/blob/master/doc/best_practices.md][best-practices]]
- includes UIOP
** Reference Projects
*** StumpWM
- [[https://github.com/stumpwm/stumpwm][github]]
*** Nyxt
- [[https://github.com/atlas-engineer/nyxt][github]]
*** Kons-9
- [[https://github.com/kaveh808/kons-9][github]]
*** cl-torrents
- [[https://github.com/vindarel/cl-torrents][github]]
*** Mezzano
- [[https://github.com/froggey/Mezzano][github]]
*** yalo
- [[https://github.com/whily/yalo][github]]
*** cl-ledger
- [[https://github.com/ledger/cl-ledger][github]]
*** Lem
- [[https://github.com/lem-project/lem][github]]
*** kindista
- [[https://github.com/kindista/kindista][github]]
*** lisp-chat
- [[https://github.com/ryukinix/lisp-chat][github]]
* Forth                                                               :forth:
As DH would say, Forth is a Blub+Non-Flub language and Lisp is a Non-Blub+Flub
language. It seems the two would be a natural pairing.

To my knowledge no one has successfully deployed a modern Forth+Lisp stack and we're not
about to try. We are already committed to Rust+Lisp and Forth doesn't really compete
with either lang anyways. We will however be ever inspired by the Forth Philosophy and
it will play a role in our development, although we may never refer to it directly.

The tell-all tale is best described by Chuck himself in 'A Problem Oriented Programming
Language'. The program which he describes receives words as input and produces machine
code. It is a compiler, interpreter, and assembler which closely resembles an
iterator. Internally it calls a core =NEXT= routine.

What I love so much about this book is that Chuck understands computers. He has
something which I've come to know as /Machine Empathy/ and a lifetime of experience to
back it up. Unlike the vast majority of programmers, Chuck pays close attention to the
welfare of the computer. Chuck understands that machines have preferences, opinions
even. A machine may be healthy, or it could be sick. The *happiness* of the machine is
an end in itself and the best way to keep our machine happy is by writing *good codes*,
or at least, the best available codes. The only way to do this, is to do it yourself.

If the machine is in good health and is happy with your codes, the problem you need to
solve becomes beautifully simple. 

There are many stack machines in the programs we build, so it comes in handy to have a
foundation of 'stack semantics' to build on and a 'control language' to operate it
with. Forth is both of these things, and it's a no-code dependency ;).
- [[https://wiki.c2.com/?ForthVsLisp][Forth vs Lisp]]
- [[https://www.greenarraychips.com/][GreenArrays, Inc.]]
* Style
- note: this isn't about 'code style'. this is about UI/UX.
** colors
- [[https://wildbit.com/blog/accessible-palette-stop-using-hsl-for-color-systems][Stop Using HSL for Color Systems]]
* Market
** Oracle
- ZFS
- [[https://www.oracle.com/storage/nas/]]
- [[https://unthought.net/joes-guide-to-the-oracle-zfs-appliance/][Hoe's guide to the Oracle ZFS Appliance]]
* Refs
#+print_bibliography:
